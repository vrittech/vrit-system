{
    "sourceFile": "blog/serializers/blog_serializers.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1730094573253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730096166642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,13 @@\n from rest_framework import serializers\n from ..models import Blog, BlogTags, BlogCategory\n from django.utils import timezone\n \n+\n+class BlogTagsSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = BlogTags\n+        fields = ['id', 'name']\n class BlogListSerializers(serializers.ModelSerializer):\n     category = serializers.StringRelatedField(many=True)\n     tags = serializers.StringRelatedField(many=True)\n \n"
                },
                {
                    "date": 1730266044102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n class BlogTagsSerializer(serializers.ModelSerializer):\n     class Meta:\n         model = BlogTags\n         fields = ['id', 'name']\n+        \n class BlogListSerializers(serializers.ModelSerializer):\n     category = serializers.StringRelatedField(many=True)\n     tags = serializers.StringRelatedField(many=True)\n \n@@ -32,8 +33,11 @@\n             'header_code', 'embedded_code', 'featured_image'\n         ]\n \n \n+from rest_framework import serializers\n+from ..models import Blog, BlogTags, BlogCategory\n+\n class BlogWriteSerializers(serializers.ModelSerializer):\n     tags = serializers.ListField(\n         child=serializers.CharField(max_length=155), write_only=True\n     )\n@@ -68,18 +72,33 @@\n \n         return blog\n \n     def update(self, instance, validated_data):\n-        tags_data = validated_data.pop('tags', [])\n-        category_data = validated_data.pop('category', [])\n+        tags_data = validated_data.pop('tags', None)\n+        category_data = validated_data.pop('category', None)\n+        featured_image = validated_data.pop('featured_image', None)\n \n+        # Update instance fields if data is provided\n         for attr, value in validated_data.items():\n             setattr(instance, attr, value)\n \n-        if tags_data:\n+        # Handle tags if provided\n+        if tags_data is not None:\n             instance.tags.set(Blog.tag_manager.get_or_create_tags(tags_data))\n-        \n-        if category_data:\n+\n+        # Handle categories if provided\n+        if category_data is not None:\n             instance.category.set(category_data)\n \n+        # Handle featured_image specifically\n+        if featured_image is not None:\n+            if featured_image == \"null\":\n+                # If image is set to 'null', delete the current image\n+                instance.featured_image.delete(save=False)\n+                instance.featured_image = None\n+            else:\n+                # If image data is sent, update it\n+                instance.featured_image = featured_image\n+\n         instance.save()\n         return instance\n+\n"
                },
                {
                    "date": 1730266050180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,102 @@\n+from rest_framework import serializers\n+from ..models import Blog, BlogTags, BlogCategory\n+from django.utils import timezone\n+\n+\n+class BlogTagsSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = BlogTags\n+        fields = ['id', 'name']\n+        \n+class BlogListSerializers(serializers.ModelSerializer):\n+    category = serializers.StringRelatedField(many=True)\n+    tags = serializers.StringRelatedField(many=True)\n+\n+    class Meta:\n+        model = Blog\n+        fields = [\n+            'id', 'title', 'excerpt', 'status', 'publish_date', \n+            'created_at', 'updated_at', 'category', 'tags'\n+        ]\n+\n+\n+class BlogRetrieveSerializers(serializers.ModelSerializer):\n+    category = serializers.StringRelatedField(many=True)\n+    tags = serializers.StringRelatedField(many=True)\n+\n+    class Meta:\n+        model = Blog\n+        fields = [\n+            'id', 'title', 'description', 'status', 'publish_date', \n+            'meta_description', 'meta_keywords', 'meta_author',\n+            'created_at', 'updated_at', 'category', 'tags', \n+            'header_code', 'embedded_code', 'featured_image'\n+        ]\n+\n+\n+\n+class BlogWriteSerializers(serializers.ModelSerializer):\n+    tags = serializers.ListField(\n+        child=serializers.CharField(max_length=155), write_only=True\n+    )\n+    category = serializers.ListField(\n+        child=serializers.IntegerField(), write_only=True\n+    )\n+\n+    class Meta:\n+        model = Blog\n+        fields = [\n+            'id', 'title', 'description', 'site_title', 'excerpt', \n+            'status', 'publish_date', 'meta_description', 'meta_keywords', \n+            'meta_author', 'tags', 'category', 'header_code', 'embedded_code', \n+            'featured_image'\n+        ]\n+\n+    def validate_publish_date(self, value):\n+        \"\"\"\n+        Ensure that publish_date is in the future for scheduled blogs.\n+        \"\"\"\n+        if self.initial_data.get('status') == 'scheduled' and value <= timezone.now().date():\n+            raise serializers.ValidationError(\"Publish date must be in the future for scheduled blogs.\")\n+        return value\n+\n+    def create(self, validated_data):\n+        tags_data = validated_data.pop('tags', [])\n+        category_data = validated_data.pop('category', [])\n+        \n+        blog = Blog.objects.create(**validated_data)\n+        blog.tags.set(Blog.tag_manager.get_or_create_tags(tags_data))\n+        blog.category.set(category_data)\n+\n+        return blog\n+\n+    def update(self, instance, validated_data):\n+        tags_data = validated_data.pop('tags', None)\n+        category_data = validated_data.pop('category', None)\n+        featured_image = validated_data.pop('featured_image', None)\n+\n+        # Update instance fields if data is provided\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n+\n+        # Handle tags if provided\n+        if tags_data is not None:\n+            instance.tags.set(Blog.tag_manager.get_or_create_tags(tags_data))\n+\n+        # Handle categories if provided\n+        if category_data is not None:\n+            instance.category.set(category_data)\n+\n+        # Handle featured_image specifically\n+        if featured_image is not None:\n+            if featured_image == \"null\":\n+                # If image is set to 'null', delete the current image\n+                instance.featured_image.delete(save=False)\n+                instance.featured_image = None\n+            else:\n+                # If image data is sent, update it\n+                instance.featured_image = featured_image\n+\n+        instance.save()\n+        return instance\n+\n"
                }
            ],
            "date": 1730094573253,
            "name": "Commit-0",
            "content": "from rest_framework import serializers\nfrom ..models import Blog, BlogTags, BlogCategory\nfrom django.utils import timezone\n\nclass BlogListSerializers(serializers.ModelSerializer):\n    category = serializers.StringRelatedField(many=True)\n    tags = serializers.StringRelatedField(many=True)\n\n    class Meta:\n        model = Blog\n        fields = [\n            'id', 'title', 'excerpt', 'status', 'publish_date', \n            'created_at', 'updated_at', 'category', 'tags'\n        ]\n\n\nclass BlogRetrieveSerializers(serializers.ModelSerializer):\n    category = serializers.StringRelatedField(many=True)\n    tags = serializers.StringRelatedField(many=True)\n\n    class Meta:\n        model = Blog\n        fields = [\n            'id', 'title', 'description', 'status', 'publish_date', \n            'meta_description', 'meta_keywords', 'meta_author',\n            'created_at', 'updated_at', 'category', 'tags', \n            'header_code', 'embedded_code', 'featured_image'\n        ]\n\n\nclass BlogWriteSerializers(serializers.ModelSerializer):\n    tags = serializers.ListField(\n        child=serializers.CharField(max_length=155), write_only=True\n    )\n    category = serializers.ListField(\n        child=serializers.IntegerField(), write_only=True\n    )\n\n    class Meta:\n        model = Blog\n        fields = [\n            'id', 'title', 'description', 'site_title', 'excerpt', \n            'status', 'publish_date', 'meta_description', 'meta_keywords', \n            'meta_author', 'tags', 'category', 'header_code', 'embedded_code', \n            'featured_image'\n        ]\n\n    def validate_publish_date(self, value):\n        \"\"\"\n        Ensure that publish_date is in the future for scheduled blogs.\n        \"\"\"\n        if self.initial_data.get('status') == 'scheduled' and value <= timezone.now().date():\n            raise serializers.ValidationError(\"Publish date must be in the future for scheduled blogs.\")\n        return value\n\n    def create(self, validated_data):\n        tags_data = validated_data.pop('tags', [])\n        category_data = validated_data.pop('category', [])\n        \n        blog = Blog.objects.create(**validated_data)\n        blog.tags.set(Blog.tag_manager.get_or_create_tags(tags_data))\n        blog.category.set(category_data)\n\n        return blog\n\n    def update(self, instance, validated_data):\n        tags_data = validated_data.pop('tags', [])\n        category_data = validated_data.pop('category', [])\n\n        for attr, value in validated_data.items():\n            setattr(instance, attr, value)\n\n        if tags_data:\n            instance.tags.set(Blog.tag_manager.get_or_create_tags(tags_data))\n        \n        if category_data:\n            instance.category.set(category_data)\n\n        instance.save()\n        return instance\n"
        }
    ]
}